import logging
import boto3
import time
import os
import asyncio
import json  # –î–æ–±–∞–≤–ª—è–µ–º –∏–º–ø–æ—Ä—Ç –º–æ–¥—É–ª—è json
from datetime import datetime
from telethon import TelegramClient, events, Button
from telethon.tl.types import ChannelParticipantsAdmins
from telethon.tl.functions.channels import GetParticipantsRequest
from telethon.errors import FloodWaitError, SessionPasswordNeededError
from botocore.exceptions import ClientError
from telethon.tl.functions.messages import SetTypingRequest
from telethon.tl.types import SendMessageTypingAction
import sib_api_v3_sdk
from sib_api_v3_sdk.rest import ApiException

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Telegram API
API_ID = 24502638
API_HASH = '751d5f310032a2f2b1ec888bd5fc7fcb'
BOT_TOKEN = '7512734081:AAGVNe3SGMdY1AnaJwu6_mN4bKTxp3Z7hJs'

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è S3 –∏ DynamoDB
S3_CLIENT = boto3.client('s3')
DYNAMODB = boto3.resource('dynamodb', region_name='eu-north-1')
TABLE = DYNAMODB.Table('telegram-subscribers-new')
USERS_TABLE = DYNAMODB.Table('my-telegram-users')  # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Brevo
BREVO_API_KEY = os.getenv('BREVO_API_KEY')  # –ü–æ–ª—É—á–µ–Ω–∏–µ API –∫–ª—é—á–∞ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è

if not BREVO_API_KEY:
    logger.error("BREVO_API_KEY –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
    raise ValueError("BREVO_API_KEY –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è.")

# –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É —Å–µ—Å—Å–∏–∏
SESSION_FILE = '/tmp/bot_session.session'

# ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ broadcast
BROADCAST_USER_ID = 177520168

async def connect_with_retry(client, max_retries=5):
    for attempt in range(max_retries):
        try:
            await client.connect()
            return
        except FloodWaitError as e:
            if attempt == max_retries - 1:
                raise
            wait_time = e.seconds
            logger.info(f"–û–∂–∏–¥–∞–Ω–∏–µ {wait_time} —Å–µ–∫—É–Ω–¥ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π...")
            time.sleep(wait_time)

async def initialize_client():
    client = TelegramClient(SESSION_FILE, API_ID, API_HASH)
    if not os.path.exists(SESSION_FILE):
        await connect_with_retry(client)
        await client.sign_in(bot_token=BOT_TOKEN)
        await client.session.save()
    else:
        await client.start(bot_token=BOT_TOKEN)
    return client

async def send_message(client, chat_id, text, buttons=None):
    try:
        if buttons:
            await client.send_message(chat_id, text, buttons=buttons)
        else:
            await client.send_message(chat_id, text)
        logger.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ –≤ —á–∞—Ç {chat_id}")
        await asyncio.sleep(1)  # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –≤ 1 —Å–µ–∫—É–Ω–¥—É –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
        raise

async def show_typing_animation(client, chat_id, duration=3):
    try:
        await client(SetTypingRequest(peer=chat_id, action=SendMessageTypingAction()))
        await asyncio.sleep(duration)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –∞–Ω–∏–º–∞—Ü–∏–∏ –Ω–∞–±–æ—Ä–∞ —Ç–µ–∫—Å—Ç–∞: {e}")

async def verify_channel_admin(client, user_id, channel_name):
    try:
        channel = await client.get_entity(channel_name)
        admins = await client(GetParticipantsRequest(
            channel, filter=ChannelParticipantsAdmins(), offset=0, limit=100, hash=0))
        return any(admin.id == user_id for admin in admins.users)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞: {e}")
        raise

async def get_subscribers_list(client, channel):
    try:
        channel_entity = await client.get_entity(channel)
        participants = await client.get_participants(channel_entity)
        return {str(p.id): f'{p.first_name or ""} {p.last_name or ""} (@{p.username or "N/A"})' for p in participants}
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: {e}")
        raise

async def send_channel_connected_message(client, chat_id, channel_name, subscriber_count, subscriber_list):
    message = (
        f"–•–µ–π-—Ö–µ–π! –ú—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏ –∫–∞–Ω–∞–ª –∏ —Ç–µ–ø–µ—Ä—å –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –±—É–¥–µ–º –ø—Ä–∏—Å—ã–ª–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–º, "
        f"–∫—Ç–æ –ø–æ–¥–ø–∏—Å–∞–ª—Å—è, –∞ –∫—Ç–æ –æ—Ç–ø–∏—Å–∞–ª—Å—è –æ—Ç –∫–∞–Ω–∞–ª–∞.\n\n"
        f"–ù–∞ —Å–µ–≥–æ–¥–Ω—è—à–Ω–∏–π –¥–µ–Ω—å —É —Ç–µ–±—è: {subscriber_count}\n\n"
        f"–í–æ—Ç –∏—Ö —Å–ø–∏—Å–æ–∫:\n"
    )
    
    for user_id, user_info in subscriber_list.items():
        name, subscriber_username = user_info.split(' (@')
        subscriber_username = subscriber_username.rstrip(')')
        message += f"üéâ {name} (@{subscriber_username}) ‚Äî https://t.me/{subscriber_username}\n"
    
    try:
        await send_message(client, chat_id, message)
        logger.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫–∞–Ω–∞–ª–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ —á–∞—Ç {chat_id}")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫–∞–Ω–∞–ª–∞: {e}")
        raise

def send_email(channel_name, admin_email, subscriber_count, subscriber_list):
    configuration = sib_api_v3_sdk.Configuration()
    configuration.api_key['api-key'] = BREVO_API_KEY
    api_instance = sib_api_v3_sdk.TransactionalEmailsApi(sib_api_v3_sdk.ApiClient(configuration))

    admin_email_subject = f'–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ {channel_name}'
    admin_email_body = (f'–ö–∞–Ω–∞–ª {channel_name} —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω.\n'
                        f'–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: {subscriber_count}\n'
                        f'–°–ø–∏—Å–æ–∫ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤:\n')
    
    subscriber_dict = json.loads(subscriber_list)
    for user_id, user_info in subscriber_dict.items():
        name, subscriber_username = user_info.split(' (@')
        subscriber_username = subscriber_username.rstrip(')')
        admin_email_body += f"üéâ {name} (@{subscriber_username}) ‚Äî https://t.me/{subscriber_username}\n"
    
    owner_email_subject = f'–ü–æ–¥–∫–ª—é—á–µ–Ω –Ω–æ–≤—ã–π –∫–∞–Ω–∞–ª {channel_name}'
    owne...(about 3886 chars omitted)...\n\n"
                           "–ü–æ –≤—Å–µ–º –≤–æ–ø—Ä–æ—Å–∞–º –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å –∫ @alex_favin")
        await send_message(client, chat_id, welcome_message)
    elif text.startswith('@'):
        channel_name = text
        is_admin = await verify_channel_admin(client, user_id, channel_name)
        if is_admin:
            await send_message(client, chat_id, "–ö–∞–Ω–∞–ª —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏—Ç–µ –≤–∞—à—É —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω—É—é –ø–æ—á—Ç—É.")
            try:
                subscribers = await get_subscribers_list(client, channel_name)
                save_channel_to_dynamodb(channel_name, user_id, subscribers, admin_name=user_name)
                logger.info(f"–ö–∞–Ω–∞–ª {channel_name} —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ DynamoDB –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∫–∞–Ω–∞–ª–∞ {channel_name} –≤ DynamoDB –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {str(e)}")
                await send_message(client, chat_id, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
        else:
            await send_message(client, chat_id, "–í—ã –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º —ç—Ç–æ–≥–æ –∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –±–æ—Ç –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
    elif '@' in text and '.' in text:  # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ email
        email = text
        try:
            channel_name = get_channel_from_dynamodb(user_id)
            logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ –∏–∑ DynamoDB –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {channel_name}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞ –∏–∑ DynamoDB –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {str(e)}")
            channel_name = None
        
        if channel_name:
            try:
                subscribers = await get_subscribers_list(client, channel_name)
                logger.info(f"–ü–æ–ª—É—á–µ–Ω —Å–ø–∏—Å–æ–∫ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –¥–ª—è –∫–∞–Ω–∞–ª–∞ {channel_name}")
                send_email(channel_name, email, len(subscribers), json.dumps(subscribers, ensure_ascii=False, indent=2))
                logger.info(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ email –Ω–∞ –∞–¥—Ä–µ—Å {email} —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –∫–∞–Ω–∞–ª–µ {channel_name}")
                await send_message(client, chat_id, f"–ö–∞–Ω–∞–ª {channel_name} —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω! –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ {email}")
                save_channel_to_dynamodb(channel_name, user_id, subscribers, email, admin_name=user_name)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ email {email} –¥–ª—è –∫–∞–Ω–∞–ª–∞ {channel_name}: {str(e)}")
                await send_message(client, chat_id, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
        else:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∫–∞–Ω–∞–ª –≤ DynamoDB –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
            await send_message(client, chat_id, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞ –∑–∞–Ω–æ–≤–æ —Å –∫–æ–º–∞–Ω–¥—ã /start")
    elif user_id == BROADCAST_USER_ID and text.startswith('/broadcast '):
        broadcast_message = text[len('/broadcast '):]
        await broadcast_message_to_all_users(client, broadcast_message)
        await send_message(client, chat_id, "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.")
    else:
        await send_message(client, chat_id, "–Ø –Ω–µ –ø–æ–Ω–∏–º–∞—é —ç—Ç—É –∫–æ–º–∞–Ω–¥—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –Ω–∞—á–∞–ª–∞.")

def get_channel_from_dynamodb(admin_user_id):
    try:
        response = TABLE.query(
            IndexName='AdminUserIndex',
            KeyConditionExpression='admin_user_id = :admin_id',
            ExpressionAttributeValues={':admin_id': str(admin_user_id)},
            Limit=1
        )
        items = response.get('Items', [])
        if items:
            return items[0]['channel_id']
        return None
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞ –∏–∑ DynamoDB: {e}")
        return None

async def broadcast_message_to_all_users(client, message):
    try:
        response = USERS_TABLE.scan()
        users = response.get('Items', [])
        for user in users:
            if 'user_id' in user:
                chat_id = int(user['user_id'])
                try:
                    entity = await client.get_input_entity(chat_id)
                    await send_message(client, entity, message)
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {chat_id}: {e}")
                await asyncio.sleep(1)  # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –≤ 1 —Å–µ–∫—É–Ω–¥—É –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
        logger.info("–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º: {e}")
        raise

async def main(event):
    logger.info("–ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏—è")
    logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ —Å–æ–±—ã—Ç–∏–µ: {event}")
    try:
        client = await initialize_client()
        logger.info("–£—Å–ø–µ—à–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Telegram API")
        
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Å–æ–±—ã—Ç–∏—è
        if isinstance(event, dict):
            if 'body' in event:
                try:
                    body = json.loads(event['body'])
                except json.JSONDecodeError:
                    logger.error(f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å JSON –∏–∑ body: {event['body']}")
                    return
            elif 'message' in event:
                body = event
            else:
                logger.warning(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å–æ–±—ã—Ç–∏—è. –ö–ª—é—á–∏: {event.keys()}")
                logger.info(f"–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ–±—ã—Ç–∏—è: {event}")
                return
        else:
            logger.error(f"–°–æ–±—ã—Ç–∏–µ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Å–ª–æ–≤–∞—Ä–µ–º. –¢–∏–ø: {type(event)}")
            return

        if 'message' not in body:
            logger.warning(f"–í —Ç–µ–ª–µ —Å–æ–±—ã—Ç–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∫–ª—é—á 'message'. –ö–ª—é—á–∏ body: {body.keys()}")
            logger.info(f"–°–æ–¥–µ—Ä–∂–∏–º–æ–µ body: {body}")
            return

        message = body['message']
        chat_id = message['chat']['id']
        user_id = message['from']['id']
        text = message.get('text', '')
        user_name = message['from'].get('username', '')

        logger.info(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è: chat_id={chat_id}, user_id={user_id}, user_name={user_name}, text={text}")

        await process_message(client, chat_id, text, user_id, user_name)

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–±—ã—Ç–∏—è: {str(e)}")
        raise
    finally:
        if 'client' in locals():
            await client.disconnect()

def lambda_handler(event, context):
    logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ —Å–æ–±—ã—Ç–∏–µ Lambda: {event}")
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(event))
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ lambda_handler: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }
    return {'statusCode': 200, 'body': json.dumps('OK')}
